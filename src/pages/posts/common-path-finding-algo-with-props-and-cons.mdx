---
title: 'common path finding algo with props and cons?'
pubDate: 2024-04-18
description: 'path finding!'
author: 'Ankan Roy'
layout: ../../layouts/Page.astro
---

### Dijkstra's algorithm 
is a widely used path-finding algorithm that finds the shortest path between two nodes in a weighted graph. Here's a more detailed explanation of the algorithm, along with its pros and cons:

Dijkstra's Algorithm:
1. **Initialization**: Set the distance to the starting node as 0 and the distance to all other nodes as infinity.
2. **Selection**: Select the unvisited node with the smallest distance from the set of unvisited nodes.
3. **Relaxation**: For each unvisited neighbor of the selected node, update the distance to that neighbor if the sum of the distance to the selected node and the weight of the edge between the selected node and the neighbor is smaller than the current distance to the neighbor.
4. **Repeat**: Repeat steps 2 and 3 until all nodes have been visited.

Pros of Dijkstra's Algorithm:
1. **Optimality**: Dijkstra's algorithm is guaranteed to find the shortest path between the starting node and the destination node, as long as all edge weights are non-negative.
2. **Simplicity**: The algorithm is relatively straightforward to understand and implement, making it a popular choice for many applications.
3. **Versatility**: Dijkstra's algorithm can be used in a wide range of applications, including route planning, network routing, and resource allocation.

Cons of Dijkstra's Algorithm:
1. **Time Complexity**: The time complexity of Dijkstra's algorithm is O(E + V log V), where E is the number of edges and V is the number of vertices in the graph. This makes it less efficient for large graphs with many edges and vertices.
2. **Memory Complexity**: Dijkstra's algorithm requires storing the distances and previous nodes for each visited vertex, which can consume a lot of memory, especially for large graphs.
3. **Negative Edge Weights**: Dijkstra's algorithm cannot handle graphs with negative edge weights, as it may produce incorrect results in such cases.
4. **Lack of Heuristics**: Dijkstra's algorithm does not use any heuristic information to guide the search, which can make it less efficient than other algorithms, such as A* search, in some cases.

To address the limitations of Dijkstra's algorithm, various modifications and alternative algorithms have been developed, such as the A* search algorithm, which incorporates a heuristic function to guide the search, and the Bellman-Ford algorithm, which can handle graphs with negative edge weights.

```python
from collections import deque
from typing import Dict, Tuple

def dijkstra(graph: Dict[str, Dict[str, int]], start: str, end: str) -> Tuple[dict, dict]:
    """
    Implements Dijkstra's algorithm to find the shortest path between a start and end node in a weighted graph.

    Args:
        graph (Dict[str, Dict[str, int]]): The graph represented as a dictionary of dictionaries, where the outer
                                          dictionary keys are the nodes and the inner dictionary keys are the
                                          neighboring nodes and the values are the weights of the edges.
        start (str): The starting node.
        end (str): The ending node.

    Returns:
        Tuple[dict, dict]: A tuple containing two dictionaries:
            1. The first dictionary maps each node to the distance from the start node.
            2. The second dictionary maps each node to the previous node in the shortest path.
    """
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    previous = {node: None for node in graph}
    queue = deque([start])

    while queue:
        current_node = queue.popleft()

        if current_node == end:
            break

        for neighbor, weight in graph[current_node].items():
            distance = distances[current_node] + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_node
                queue.append(neighbor)

    return distances, previous

# Example usage
graph = {
    'A': {'B': 5, 'C': 1},
    'B': {'A': 5, 'C': 2, 'D': 1},
    'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
    'D': {'B': 1, 'C': 4, 'E': 3, 'F': 6},
    'E': {'C': 8, 'D': 3},
    'F': {'D': 6}
}

start = 'A'
end = 'F'

distances, previous = dijkstra(graph, start, end)
print(f"Shortest distance from {start} to {end}: {distances[end]}")
print(f"Shortest path from {start} to {end}: ", end='')
path = []
node = end
while node is not None:
    path.append(node)
    node = previous[node]
print(' -> '.join(reversed(path)))
```